---
author: Kai Magnus Müller
datePublished: 2025-07-30T09:00:00Z
title: 'FigmaKit: A Component Library for Plugin UIs'
draft: false
tags:
    - Svelte
    - Library
    - Figma
    - Component Library
    - Plugin Development
ogImage: ''
description: Learn how I built FigmaKit, a comprehensive Svelte component library that replicates Figma's native UI, and how it powers ContentKit and other plugin projects.
---

import Figure from '@components/Figure.astro';

While building [ContentKit](/work/contentkit-a-platform-for-design-automation) over the past year, I also built a Svelte 5 based component library alongside it. It is a modernized and extended version of [figma-plugin-ds-svelte](https://github.com/thomas-lowry/figma-plugin-ds-svelte), a library created by Thomas Lowry (designer advocate at Figma), which I've used for the [Tree Navigator](using-the-tree-navigator-plugin) plugin before. Today I want to share why I built it, how it works, and what I learned while building it.

## The Problem with Figma Plugin UIs

If you've used Figma plugins extensively, you've probably noticed how inconsistent their interfaces can be. Some plugins feel native and integrated, some look pretty ok with some inconsistencies, while others feel like they were built with random components and dropped into Figma. This inconsistency isn't just aesthetic, sometimes basic functionality is broken and it's simply not a nice experience for users who are familiar with Figma's interface patterns.

When I started building ContentKit, I initially used basic HTML elements and a small stylesheet to make them look like Figma's UI. While that initially worked for buttons, and the basic structure, ContentKit quickly became much more complex and needed more UI elements than were available in the library linked above. This, together with the fact that I wanted to build two things, a web app and plugin, ideally on top of the same Svelte 5 base, made me decide to take this as a starting point for my own library. UI3 was also seeing more adoption, so to maintain the native feel going forward, I wanted a clean technical and visual base.

{/* [PLACEHOLDER: Add personal experience about the initial challenges building ContentKit's UI and user feedback about interface consistency] */}

## Building FigmaKit

FigmaKit uses a very similar prop structure as the original library, but

Rather than continue building one-off components for each new feature, I decided to extract the UI patterns into a reusable library. FigmaKit aims to replicate Figma's UI3 interface as closely as possible, providing Svelte components that feel native to the Figma environment.

The library includes all the essential components you'd expect: buttons, inputs, checkboxes, switches, and more specialized components like dialogs and dropdowns.

### Button Components: Getting the Details Right

Let's look at how the `Button` component works. Figma's buttons have specific variants (primary, secondary, tertiary), consistent sizing, and careful attention to states like hover, focus, and disabled. Here's how you use it in FigmaKit:

```svelte
<Button variant="primary" onclick={() => console.log('Primary clicked')}>
  Primary Action
</Button>
<Button variant="secondary" size="large" icon={IconAdjust}>
  Secondary
</Button>
<Button variant="tertiary" destructive>
  Delete
</Button>
```

The component supports all the variants you see in Figma's interface, including the destructive styling for actions like deletion. Icon support is built-in, and the sizing exactly matches what users expect from Figma's native buttons.

{/* [PLACEHOLDER: Add details about the specific design decisions made while studying Figma's interface patterns and any challenges in matching exact spacing/colors] */}

### Form Components: Consistency in Data Entry

Form components like `Input`, `Checkbox`, and `Switch` maintain Figma's interaction patterns while providing the flexibility needed for plugin development:

```svelte
<Input label="Email" placeholder="Enter your email" />
<Input label="Search" icon={IconSearch} />
<Input label="Name" invalid errorMessage="Name is required" />

<Checkbox checked>Enable notifications</Checkbox>
<Switch checked>Dark mode</Switch>
```

These components handle validation states, proper focus management, and accessibility features while maintaining the visual consistency users expect.

### Advanced Components: MultiMenu and Dialog

Some of FigmaKit's more complex components, like `MultiMenu` and `Dialog`, replicate Figma's sophisticated interface patterns:

```svelte
<MultiMenu
  groups={menuGroups}
  showSelectedValues
  triggerType="select"
/>

<Dialog bind:dialog={myDialog} title="Confirmation">
  <p>Are you sure you want to continue?</p>
  <Button onclick={() => myDialog?.close()}>Close</Button>
</Dialog>
```

The `MultiMenu` component is particularly interesting from an architectural perspective because it demonstrates how complex, nested UI patterns can be elegantly handled through recursive component design.

#### Recursive Structure: Menus Within Menus

The real power of `MultiMenu` lies in its recursive structure. Each menu group can contain not just simple options, but other menu groups, creating infinitely nested dropdown hierarchies that mirror Figma's own complex menu systems:

```javascript
const menuGroups = [
    {
        name: 'text-options',
        mode: 'single',
        children: [
            { label: 'Left Align', value: 'left', selected: true },
            { label: 'Center Align', value: 'center' },
            {
                label: 'Advanced Options',
                children: [
                    {
                        name: 'spacing',
                        mode: 'multi',
                        children: [
                            { label: 'Letter Spacing', value: 'letter', selected: true },
                            { label: 'Line Height', value: 'line' },
                        ],
                    },
                ],
            },
        ],
    },
];
```

This recursive data structure is handled by the component's `popoverContainer` and `multiMenuGroup` snippets, which call themselves when they encounter nested groups. The component uses Svelte 5's snippet feature to create reusable template fragments that can render both individual menu options and entire sub-menu structures.

#### Popover Positioning and State Management

Each nested level creates its own popover with a unique anchor name generated using `crypto.getRandomValues()`. The component cleverly manages multiple open popovers simultaneously, using CSS anchor positioning to ensure each submenu appears correctly relative to its parent:

```svelte
{#snippet popoverContainer(_groups: MenuGroup[], anchorName?: string)}
  <div
    role="menu"
    popover=""
    id={anchorName}
    style={`position-anchor: ${anchorName};`}
    onmouseleave={() => hidePopovers(menuContainerAnchor)}
  >
    <!-- Recursive rendering of groups -->
  </div>
{/snippet}
```

The recursive nature extends to state collection as well. The `collectSelectedOptions` function recursively traverses the entire menu tree to gather selected values from all levels, ensuring that selections in deeply nested submenus are properly tracked and reported.

The `Dialog` component provides modal functionality with proper focus trapping and keyboard navigation.

## How FigmaKit Powers ContentKit

In ContentKit, FigmaKit components are used throughout both the Figma plugin interface and the companion web application. Because both applications are built with Svelte, I can share components between them while using different stylesheets—the plugin uses Figma's design tokens, while the web app uses a more traditional web interface styling.

{/* [PLACEHOLDER: Add specific examples of how FigmaKit components are used in ContentKit's interface, including screenshots or specific use cases like the data table, assignment interface, or settings panels] */}

This component sharing approach has been invaluable for maintaining consistency between the plugin and web experiences while significantly reducing development time.

## Implementation Details: Svelte 5 and Modern Patterns

FigmaKit is built with Svelte 5, taking advantage of its new reactivity system and improved component patterns. The library uses modern CSS custom properties for theming, making it easy to adapt components for different contexts or future Figma UI updates.

```css
/* Example of CSS custom properties used in FigmaKit */
--figma-color-bg: #ffffff;
--figma-color-bg-secondary: #f9f9f9;
--figma-color-text: #000000;
--figma-color-text-secondary: #888888;
```

Each component is designed to be lightweight and performant, important considerations for plugin environments where bundle size and runtime performance matter.

## Icons: Learning from Figma's Approach

One interesting challenge was handling icons. Taking inspiration from my previous work on [icon component systems](/articles/create-robust-figma-icon-components), FigmaKit includes essential Figma UI icons and provides patterns for adding custom icons.

The library encourages copying SVG icons directly from Figma's interface using browser dev tools—a practical approach that ensures you have access to the exact icons users see in the native interface:

```svelte
<Icon icon={copiedSvgString} size={16} />
<Icon icon={IconCheck} color="--figma-color-icon-success" />
```

{/* [PLACEHOLDER: Add details about the process of extracting icons from Figma's interface and any tools or workflows developed for this] */}

## Looking Forward: A Foundation for Plugin Development

FigmaKit has become the foundation for all my Figma plugin projects. It's allowed me to focus on plugin functionality rather than rebuilding UI components, and the consistency it provides has improved user experience across all my tools.

The library is available on npm and includes comprehensive documentation with live examples. I've also created a playground file where you can see all components in action and understand how they integrate with typical plugin workflows.

## Try FigmaKit

You can get started with FigmaKit by installing it from npm:

```bash
npm install figmakit-plugin-ui-svelte
```

The library includes TypeScript definitions, CSS custom property autocomplete support for VS Code, and comprehensive documentation. Whether you're building your first Figma plugin or looking to improve an existing one, FigmaKit provides the components you need to create interfaces that feel truly native to Figma.

{/* [PLACEHOLDER: Add information about future plans for the library, community contributions, or specific features planned for upcoming releases] */}

Visit the [FigmaKit repository](https://github.com/KaiMagnusMueller/figmakit-plugin-ui) to learn more, and let me know what you think on [Threads](https://www.threads.net/@ofcoursekai). I'm excited to see what you build with it!
